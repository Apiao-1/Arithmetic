# Arithmetic
试题来源：杭电OJ http://acm.hdu.edu.cn/listproblem.php?vol=1

## 试题小计
#### 1002 大数加法 
debug好久一直WA，还用上了对拍器，最后发现是输出的“case”应该是“Case” 
/(ㄒoㄒ)/~~

## PAT系列

#### 1060 Are They Equal (25)⭐️
考察科学计数法的转化，此题的测试用例涵盖有特殊情况，例：0000001、0.0000001、0.0与0的判断；故在处理之前需先处理数字前方的0
解决思路:
1.对数字进行预处理，去掉开头部分的0；
2.第二部根据小数点位置区分小数或非小数，计算阶码e；
3.根据有效位数输出有效数字部分，需考虑精度高于该数字时以0补足

（将科学计数法转化为一般式见题1073）

#### 1001 A+B Format (20) 

思路很简单，转化为字符串后每隔三位输出一个逗号，但每隔三位的把握卡了很久（未考虑到原始数位数的影响）

正解：(i+1) % 3 == length % 3 && (i+1)!=length 

#### 1133 Splitting A Linked List (25)⭐️ 

该题需注意
1.链表结构的存储用数组会大大提高写代码的效率；
2.注意最后的输出，小技巧（题意要求每一个节点的next节点都指向新的节点，只需把下一个节点的当前位置输出两遍即可，无需更改真实的指向）

#### 1068 Find More Coins (30)⭐️

01背包的变种问题，需要注意的是输出01背包的解，需添加choice\[i][j]数组
另：暴力dfs可解决

#### 1044 Shopping in Mars (25)

O(n^2)复杂度会有三组测试用例超时，此时改用二分法将复杂度下降为O(nlgn)

注意若超时的话，优先检查是否将**输入输出换成scanf 和 printf**

在输入输出量非常大时，能节省非常可观的时间

#### 1018 Public Bike Management (30)⭐️⭐

dijkstra（记录路径） + DFS
好题，目前碰到的考dijkstra最全面最复杂的题，涉及到用pre\[i]向量来多条最短路径，再用DFS模拟过程

#### 1003 Emergency (25)⭐️ 

dijkstra(涉及到点权值及多条最短路径的计数)

注意与1018的区分，不需要用DFS模拟路径

#### 1027 Colors in Mars (20) 

进制转换，巧妙的写法，因为0~168的十进制转换为13进制不会超过两位数，所以这个两位数为(num / 13)(num % 13)构成的数字 

#### 1007 Maximum Subsequence Sum (25)⭐️ 

最大子段和问题，多了一步求出最大字段具体的数值，牛客网上测试用例比较变态，做完好好检查下边界值

#### 1073 Scientific Notation (20) 

将科学计数法还原成一般形式

#### 1057 Stack (30) 

栈+树状数组+二分（较难）

树状数组的理解见 ：[掌握树状数组](https://www.cnblogs.com/acgoto/p/8583952.html#4041449)

#### 1067 Sort with Swap(0,*) (25)⭐️ 

此题对时间复杂度有一定要求，注意如下：

1.存储时为避免找数字的位置时每次都要从头遍历一遍，直接存储数字的位置（类似哈希表）；

2.0换到原位时，判断下一个不在位置上的数字用一个index存储，因为此前寻找的在之后一定还是有序的 

#### 1051 Pop Sequence (25) 

模拟栈的入栈出栈过程进行检验，**注意每次初始化相关STL容器**

#### 1077 Kuchiguse (20)  

最长后缀子串，需要注意的是getline的使用（gets方法目前已废除）；输入时若将字符串先直接反转，则可以免去len[k]的记录长度的数组 

#### 1045 Favorite Color Stripe (30) 

考察最长公共子序列的变种（LCS），允许元素重复

 这道题目，按照正常的思路求解，应该使用最长公共子序列算法LCS，但与常规的LCS有所差别，常规LCS是从两个序列中按索引递增顺序，不重复的选取最大公共子列，而现在的问题是在序列B中按照A中的元素顺序可重复的找出最大子列，这样说起来比较抽象，下面举个例子，对于序列： 

 A=｛2,3,1,5,6｝ B={2,2,4,1,5,5,6,3,1,1,5,6}

 如果是常规的LCS，我们找到的子列将会是{2,3,1,5,6}，因为B完全的包含了A（不必连续）

 如果是可重复的LCS，我们完全可以选择{2,2,3,1,1,5,6}，这便是变种的LCS。 

 对于常规的LCS，只有A[i] = B[j]时才让当前的最大子列长度为maxLen[i-1][j-1]+1，其他情况则取maxLen[i-1][j]或者maxLen[i][j-1]中的最大值，这样的算法只能不重复的找出子列，如果要考虑重复，应该修改算法，无论什么情况，都取maxLen[i-1][j-1]、maxLen[i-1][j]和maxLen[i][j-1]中的最大值，如果A[i]=B[j]，则在最大值的基础上+1，这样就可以处理重复的情况了。

#### 1034 Head of a Gang (30) 

方法一：DFS遍历图（推荐）

方法二：使用并查集

#### 1071 Speech Patterns (25) 

此题有几个注意点：

1.map默认按键的升序排序，此处即默认为字典序，故无需多处理；

2.特别注意若扫描到最后一位时，无论该位是否是字母都需将其加入map，否则可能产生最后一个单词未统计的情况 

#### 1072 Gas Station (30) 

做n次Dijkstra，花了很长时间找到的bug

1.答案错误时，第一步审题，第二步检查各处的初始化，例min，max，flag等的值

2.切记，字符数组保存字符串时，**一定要留一个空间保存结束符 '\0'（提示段错误）**，永远别把数组开得很极限 

#### 1063 Set Similarity (25) 

考察set与vector结合的使用，vector<set<int>> a(55);注意此处不能用[];

#### 1093 Count PAT's（25 分）

逻辑题，整个字符串扫描一遍，遍历字符串后对于每一A，它前面的P的个数和它后面的T的个数的乘积就是能构成的PAT的个数。然后把对于每一个A的结果相加即可 。

此题需额外注意对大数取模的应用：

这里由于pnum*tnum非常大直接写会出错，故加取模%1000000007

加上后还是显示答案错误，考虑到ans+(pnum*tnum)% 1000000007也会很大，再取余，AC

至于为什么要对1000000007取模，参加https://www.liuchuo.net/archives/645

#### 1046 Shortest Distance (20) 

用sum数组进行累加，顺时针情况两点见的值通过对应sum相减的方式处理，逆时针的话通过整个环的总和减去顺时针的就好 

#### 1098 Insertion or Heap Sort （25）

此题需手动模拟堆排序的排序过程，因为queue不支持遍历操作，无法输出一次操作后每个节点的情况 

考察了堆排序的模拟过程

#### 1091 Acute Stroke（30) 

BFS或DFS都可以，图的遍历 

#### 1010 Radix (25) 

通过率最低的试题，乍一看只是一道进制转化，但测试点的进制大到令人咂舌，比如214761.。。。

需要用到二分求解进制，不然会超时

#### 1037 Magic Coupon (25)

直接手动写sort的cmp函数还是会产生错误的地方，故默认排序，再分成两个部分判断即可，注意（牛客网处需要把数据类型都改成long long才可通过）

#### 1085 Perfect Sequence（25)

注意数据大小，n<10^9用long long型，此题dfs超时，用two points的思想求解

#### 1038 Recover the Smallest Number (30)

解法很巧妙，体会到了cmp函数的强大，此题的排序不是按照字典序排列就可以，而是必须保证两个字符串构成的数字是最小的才行，所以cmp函数写成return a + b < b + a;的形式，保证它排列按照能够组成的最小数字的形式排列。

#### 1014 Waiting in Line (30)

题目不是太难，考察queue的应用，反思没把bug找出来的原因：

1.忽略了题目中的“如果这个服务已经开始了，无论时间多长都要等他服务完毕”一条件；

2.注意到该条件后，最后判断是否在17点以前开始任务不应减去cost[i]进行判断（cost[i]在过程中就已被改变，故需在开始新设一个数组）

3.在初始化排队时，没注意到无法把n个窗口都排满的情况（注意到了在黄线内未排满，但忽略了人太少以致窗口都排不满)

#### 1061 Dating（20）

终于看懂了题，一开始对题目中的“since the first common capital English letter (case sensitive) shared by the first two strings is the 4th capital letter D”，产生了误解（我说原序列中相等的位置明明是6呀，怎么会是4呢）

此题WA的原因——每次输出时分秒时注意控制%02d，不能光控制了分，不控制时

#### 1065 A+B and C (64bit)（20

 方法一，longlong类型再判断sum是否溢出

 因为A、B的大小为[-2^63, 2^63]，用long long 存储A和B的值，以及他们相加的值sum：

 如果A > 0, B < 0 或者 A < 0, B > 0，sum是不可能溢出的

 如果A > 0, B > 0，sum可能会溢出，sum范围理应为(0, 2^64 – 2]，溢出得到的结果应该是[-2^63, -2]是个负数，所以sum <= 0时候说明溢出了

 如果A < 0, B < 0，sum可能会溢出，同理，sum溢出后结果是大于0的，所以sum >= 0 说明溢出了

 

 这里需特别注意sum = 0的溢出判断，不然PAT最后一组测试用例过不去



方法二，直接用long double类型，求出的sum不会溢出

#### 1119 Pre- and Post-order Traversals（30）

给出前序后序，转中序，递归求解

#### 1123 Is It a Complete AVL Tree（30)⭐️

AVL数+层序遍历+判断是否是完全树

考察点很全面，重要

平衡二叉树详见https://www.cnblogs.com/zhangbaochong/p/5164994.html

#### 1074 Reversing Linked List（25）

此类链表题特别注意列表长度不一定是N（虽然给出了N个Node但他们不一定连续）,固需加一个cnt处理

#### 1069 The Black Hole of Numbers（20）

两个点要注意，1.输入虽说是四位数，但可以是0001，固当str位数不足时要记得补0，2.特殊的测试用例，6174，要用do-while语句，否则程序什么都不会输出

#### 1078 Hashing（25）⭐️

考察解决哈希冲突的二次方探测法，注意：

1、此处不是双向的二次平方探测法，注意题目里写了单项(with positive increments only)

2、回忆筛法求素数的写法（注意与判断素数的区别，判断素数的条件写成j*j <= num⭐️,此处的等号不能漏）

#### 1064 Complete Binary Search Tree（30）⭐️

利用完全二叉树的性质就可以很简单地解决这道题

#### 1086 Tree Traversals Again（25)

此题一开始错处理成了还原完全二叉树再进行后序遍历，因为题目中未明确说是一颗完全二叉树，故解法错误，正解：栈实现的是二叉树的中序遍历（左根右），而每次push入值的顺序是二叉树的前序遍历（根左右），所以该题可以用二叉树前序和中序转后序的方法做

#### 1076 Forwards on Weibo（30) 

BFS**带层数的广度优先⭐️**

此题不可用dfs求解，原因：以示例为例，当输入查询6时，深搜可能先把第三轮才转发的人标记为已访问，那么return回到上一轮时，部分本应查找的人由于已被标记，跳过不再dfs，由此引起错误

#### 1092 To Buy or Not to Buy（20)

注意map的count用法，返回的是键的个数，所以只有0和1

若map[str2[i]]的值不存在则默认为0

#### 1100 Mars Numbers（20)

揉在一起考虑复杂了，因为数据明确说小于169，也就是说只有两位，直接根据len判断是否存在高位，进一步取高位低位即可

#### 1102 Invert a Binary Tree（25)

注意：1.反转二叉树就是存储的时候所有左右结点都交换；2.根结点是所有左右结点中没有出现的那个结点（重要）

#### 1103 Integer Factorization（30)

dfs,可优化的条件⭐️：1.当且仅当tmpSum <= n时，进行下一层的DFS，而不要进入下一层DFS发现不满足条件再返回，这样开销会比较大；2.pow函数花销大，可事先将其pow之后的值计入数组

#### 1030 Travel Plan（30)

Dijkstra算法 + DFS，最短路径，边权  

#### 1009 Product of Polynomials（25）

简单题，但陷阱出乎意料地多，详见程序内部注释

#### 1121 Damn Single（25）

此题需注意编号00000，固初始的id不能初始化为0；同时需注意输出位0时的格式

#### 1122 Hamiltonian Cycle（25）

哈密顿回路，统计入度出度

#### 1028 List Sorting（25）

注意一下字典序的排序，如果是string类的直接排，如果是char类型的，用strcmp(a.name, b.name) < 0

#### 1134 Vertex Cover（25）

传统的邻接表邻接图的方式去做都会超时，比较巧妙此题保存的是一条边的两个节点，之后在set查询的节点集合中，依次用find查找每条边的两个节点

#### 1110 Complete Binary Tree（25)

完全二叉树的判断（区别于满二叉树）

#### 1090 Highest Price in Supply Chain（25）

DFS+树的遍历，1079同理

#### 1040 Longest Symmetric String（25）

DP，求回文串，将原序列逆序后，即求解两个序列的最长公共子串

#### 1112 Stucked Keyboard（20)

用map的方法会更为简单，就不用getIndex转化了，此题需注意当i= len时，无论str[i] 与 str[i-1]是否相等都需要再做一次

#### 1115 Counting Nodes in a BST（30)

BST建树+DFS

#### 1099 Build A Binary Search Tree（30)

利用BST的性质，中序遍历进行赋值

#### 1126 Eulerian Path（25)

如何判断图是否有欧拉回路或者欧拉路径？

 无向图：因为欧拉路径中，除了起点与终点以外，任意点的“进”“出”次数相等，所以除了两个点为奇点（度数为奇数的点）（终点和起点）以外，其它点的度数均为偶数。

 如果是欧拉回路，奇点的个数应该为0。

 有向图：欧拉路径中，最多只有两个点的入度不等于出度。起点出度比入度大1，终点入度比出度大1。

 如果是欧拉回路，所有点的 入度=出度 。

#### 1127 ZigZagging on a Tree(30)

后序中序建树+层次遍历记录深度(类似于 PAT 1094)

#### 1124 Raffle for Weibo Followers（20)

注意题意的理解，不应该先按s分成组进行判断，因为重复时会继续往下，新的一组的序号也会随之往下